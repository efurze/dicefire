<button onclick="go()">START</button>
<br>
<textarea id="info" rows=7 cols=120>
</textarea>
<p>
<canvas id="c"  onMouseMove="mouseMove(event)" width=1000px height=1000px>

</canvas>


<script>



var Globals = {
    canvas: document.getElementById("c"),
    context: null,
    debug: function(title) {
        console.log(title, arguments);
    },
    showNumbers: false
};

Globals.context = Globals.canvas.getContext('2d');

var Dir = {
    obj: {
        NW:     0,
        N:      1,
        NE:     2,
        SE:     3,
        S:      4,
        SW:     5,
    },

    array: [
        "NW", "N", "NE", "SE", "S", "SW"
    ],

    isLegal: function(hex, dir) {
        switch (dir) {
            case Dir.obj.N:
            case "N":
                return hex.num() - (2 * Hex.prototype.NUM_WIDE) >= 0;

            case Dir.obj.NE:
            case "NE":
            case Dir.obj.SE:
            case "SE":
                return ((hex.num() + 1) % (Hex.prototype.NUM_WIDE * 2));

            case Dir.obj.S:
            case "S":
                return hex.num() + (2 * Hex.prototype.NUM_WIDE) < Hex.prototype.TOTAL_HEXES;

            case Dir.obj.NW:
            case "NW":
            case Dir.obj.SW:
            case "SW":
                return (hex.num() % (Hex.prototype.NUM_WIDE * 2));

            default:
                return false;
        }
    },

    nextHex: function(hex, dir) {
        if (!Dir.isLegal(hex, dir)) {
            return null;
        }

        var x = hex.x();
        var y = hex.y();

        var oldHexNum = hex.num();
        var newHexNum;

        // This is complicated becasue it has to look for edge conditions both N-S and E-W. The E-W direction
        // depends a bit on which row you're in. Only every other row can even have a problem.
        switch (dir) {
            case Dir.obj.NW: 
            case "NW":
                newHexNum = Math.floor(oldHexNum / Hex.prototype.NUM_WIDE) % 2 ? oldHexNum - Hex.prototype.NUM_WIDE : oldHexNum - Hex.prototype.NUM_WIDE - 1;
                break;

            case Dir.obj.N:
            case "N":
                newHexNum = oldHexNum - (2 * Hex.prototype.NUM_WIDE);
                break;

            case Dir.obj.NE:
            case "NE":
                newHexNum = Math.floor(oldHexNum / Hex.prototype.NUM_WIDE) % 2 ? oldHexNum - Hex.prototype.NUM_WIDE + 1 : oldHexNum - Hex.prototype.NUM_WIDE;
                break;

            case Dir.obj.SE:
            case "SE":
                newHexNum = Math.floor(oldHexNum / Hex.prototype.NUM_WIDE) % 2 ? oldHexNum + Hex.prototype  .NUM_WIDE + 1 : oldHexNum + Hex.prototype.NUM_WIDE;
                break;

            case Dir.obj.S:
            case "S":
                newHexNum = oldHexNum + (2 * Hex.prototype.NUM_WIDE);
                break;

            case Dir.obj.SW:
            case "SW":
                newHexNum = Math.floor(oldHexNum / Hex.prototype.NUM_WIDE) % 2 ? oldHexNum + Hex.prototype.NUM_WIDE : oldHexNum + Hex.prototype.NUM_WIDE - 1;
                break;    

        }


        return Hex.get(newHexNum);
    }
};



var Hex = function(num) {
    this._num = num;
    this._x = num % Hex.prototype.NUM_WIDE;
    this._y = Math.floor(num / Hex.prototype.NUM_WIDE);
    this._country = null;
    this._countryEdgeDirections = [];
};

Hex.init = function() {
    Hex._array = [];
    for (var i = 0; i < Hex.prototype.TOTAL_HEXES; i++) {
        Hex._array[i] = new Hex(i);
    }

};

Hex.get = function(num) {
    return Hex._array[num];
}
Hex.count = function() {
    return Hex._array.length;
}

Hex.fromMousePos = function(x, y) {
    y -= Hex.prototype.TOP_LEFT_Y;
    var total_height = Hex.prototype.NUM_HIGH * Hex.prototype.HEIGHT;
    var row = Math.floor((y / total_height) * (Hex.prototype.NUM_HIGH * 2));

    x -= Hex.prototype.TOP_LEFT_X;
    var total_width = Hex.prototype.NUM_WIDE * Hex.prototype.WIDTH;
    var col = Math.floor((x / total_width) * (Hex.prototype.NUM_WIDE / 1.5) * 2);

    var num = null;

    // Note col can be -1!
    if (col % 2) {  // Odd means it's an angled portion.
        var left = null, right = null;
        if ((col - 1) % 4) {
            if (row % 2) {
                col = Math.floor(col / 4);
                row = Math.floor(row / 2);
                left = col + (row * (Hex.prototype.NUM_WIDE * 2)) + Hex.prototype.NUM_WIDE;
                right = left - Hex.prototype.NUM_WIDE + 1;
                //bottom-right to top-left
            } else {
                col = Math.floor(col / 4);
                row = Math.floor(row / 2) - 1;
                left = col + (row * (Hex.prototype.NUM_WIDE * 2)) + Hex.prototype.NUM_WIDE;
                right = left + Hex.prototype.NUM_WIDE + 1;

                //bottom-left to top right
            }

        } else {
            if (row % 2) {
                col = Math.floor(col / 4);
                row = Math.floor(row / 2);
                left = col + (row * (Hex.prototype.NUM_WIDE * 2));
                right = left + Hex.prototype.NUM_WIDE;

                //bottom-left to top-right                
            } else {
                col = Math.floor(col / 4);
                row = Math.floor(row / 2) - 1;
                left = col + (row * (Hex.prototype.NUM_WIDE * 2)) + 2 * Hex.prototype.NUM_WIDE;
                right = left - Hex.prototype.NUM_WIDE;


                //bottom-right to top-left
            }

        }


        return left != null ? [left, right] : null;

        // [1,1] is between 0 and 40 with a bottom-left to top-right line
        // [3,1] is between 40 and 1 with a bottom-right to top-left line
        // [5,1] is between 1 and 41 with bottom-left to top-right
        // [1,2] is between 80 and 41 with top-left to bottom right
        // [3,2] is between 40 and 81 wtih bottom-left to top-right



    } else {    // Much easier: A flat portion.

        col /= 2;
        if (col % 2) { // Odd means it's a lower hex.
            col = Math.floor(col / 2);
            row = Math.floor(row / 2) - 1;
            num = col + (row * (Hex.prototype.NUM_WIDE * 2)) + Hex.prototype.NUM_WIDE;
        } else { // Even means its an upper hex.
            col /= 2;
            row = Math.floor(row / 2);
            num = col + (row * Hex.prototype.NUM_WIDE * 2);
        }
    }
    return null;

    if (num != null && num >= 0) {
        return Hex.get(num);
    }

    return null;
}


Hex.prototype.BORDER_COLOR = "black";
Hex.prototype.BORDER_THICKNESS = 3;
Hex.prototype.HEIGHT = 14;
Hex.prototype.WIDTH = Hex.prototype.HEIGHT / Math.sqrt(3);
Hex.prototype.TOP_LEFT_X = 10;
Hex.prototype.TOP_LEFT_Y = 10;
Hex.prototype.NUM_WIDE = 40;
Hex.prototype.NUM_HIGH = 80;
Hex.prototype.TOTAL_HEXES = Hex.prototype.NUM_WIDE * Hex.prototype.NUM_HIGH;

Hex.prototype.x = function() { return this._x; };
Hex.prototype.y = function() { return this._y; };
Hex.prototype.num = function() { return this._num; };


Hex.prototype.isInterior = function() {
    return this._countryEdgeDirections.length == 0;
}

Hex.prototype.isExterior = function() {
    return this._countryEdgeDirections.length > 0;
}


Hex.prototype.setCountry = function(country) {
    this._country = country;
}


// The directions which are boundaries between this cell and another country or the edge of the board.
Hex.prototype.setCountryEdgeDirections = function(array) {
    this._countryEdgeDirections = array;
}

Hex.prototype.country = function() {
    return this._country;
}

Hex.prototype.paint = function() {
    var self = this;

    var upperLeftX;
    var upperLeftY;
    if (this._y % 2) {
        var y = Math.floor(this._y / 2);
        upperLeftX = this.TOP_LEFT_X + (this.WIDTH * ((this._x * 3) + 1.5));
        upperLeftY = this.TOP_LEFT_Y + (y + 0.5) * this.HEIGHT;

    } else {
        var y = this._y / 2;
        upperLeftX = this.TOP_LEFT_X + (this.WIDTH * this._x * 3);
        upperLeftY = this.TOP_LEFT_Y + y * this.HEIGHT;
    }

    var FUDGE = 0.5;
    var path = new Path2D();
    path.moveTo(upperLeftX - FUDGE, upperLeftY - FUDGE);
    path.lineTo(upperLeftX + this.WIDTH + FUDGE, upperLeftY - FUDGE);
    path.lineTo(upperLeftX + this.WIDTH + this.WIDTH / 2, upperLeftY + this.HEIGHT / 2);
    path.lineTo(upperLeftX + this.WIDTH + FUDGE, upperLeftY + this.HEIGHT + FUDGE);
    path.lineTo(upperLeftX - FUDGE, upperLeftY + this.HEIGHT + FUDGE);
    path.lineTo(upperLeftX - this.WIDTH / 2, upperLeftY + this.HEIGHT / 2);
    path.lineTo(upperLeftX - FUDGE, upperLeftY - FUDGE);
    path.closePath();


    Globals.context.fillStyle = this._country ? this._country.color() : "white";
    if (this._color) {
        Globals.context.fillStyle = this._color;
    }
    Globals.context.fill(path);


    this._countryEdgeDirections.forEach(function(dir) {
        var edgePath = new Path2D();
        switch(dir) {
            case Dir.obj.NW: 
            case "NW":
                edgePath.moveTo(upperLeftX, upperLeftY);
                edgePath.lineTo(upperLeftX - self.WIDTH / 2, upperLeftY + self.HEIGHT / 2);
                break;

            case Dir.obj.N:
            case "N":
                edgePath.moveTo(upperLeftX, upperLeftY);
                edgePath.lineTo(upperLeftX + self.WIDTH, upperLeftY);
                break;

            case Dir.obj.NE:
            case "NE":
                edgePath.moveTo(upperLeftX + self.WIDTH, upperLeftY);
                edgePath.lineTo(upperLeftX + self.WIDTH + self.WIDTH / 2, upperLeftY + self.HEIGHT / 2);
                break;

            case Dir.obj.SE:
            case "SE":
                edgePath.moveTo(upperLeftX + self.WIDTH + self.WIDTH / 2, upperLeftY + self.HEIGHT / 2);
                edgePath.lineTo(upperLeftX + self.WIDTH, upperLeftY + self.HEIGHT);
                break;

            case Dir.obj.S:
            case "S":
                edgePath.moveTo(upperLeftX + self.WIDTH, upperLeftY + self.HEIGHT);
                edgePath.lineTo(upperLeftX, upperLeftY + self.HEIGHT);
                break;

            case Dir.obj.SW:
            case "SW":
                edgePath.moveTo(upperLeftX, upperLeftY + self.HEIGHT);
                edgePath.lineTo(upperLeftX - self.WIDTH / 2, upperLeftY + self.HEIGHT / 2);
                break;                    


        }
        edgePath.closePath();
        Globals.context.strokeColor = self.BORDER_COLOR;
        Globals.context.lineWidth = self.BORDER_THICKNESS;

        Globals.context.stroke(edgePath);

    });

    if (Globals.showNumbers) {
        Globals.context.lineWidth = 1;
        Globals.context.font = "11px sans-serif";
        Globals.context.strokeText(this._num, upperLeftX, upperLeftY + this.HEIGHT / 2);
    }

};



var Country = function(starthex, color) {
    this._hexes = [starthex];
    starthex.setCountry(this);
    this._color = color;
    this._numHexes = Math.floor(Math.random() * (Country.prototype.MAX_HEXES - Country.prototype.MIN_HEXES + 1)) + Country.prototype.MIN_HEXES

    this.growCountry();
    if (this._numHexes != this._hexes.length) {

        Globals.debug("Too small country made, making lake:", this);         
        // Mark it as a lake still so we can make enough countries.
        this._isLake = true;
        if (this._hexes.length <= 5) {
            this.absorbLake();
            return;
        } else {
            // Lake absorbed which prevents it being added to the master country list.
            this._color = this.LAKE_COLOR;  
        }
    }

    Country._array.push(this);
};

Country.init = function() {
    Country._array = [];
}

Country.get = function(num) {
    return Country._array[num];
}
Country.count = function() {
    return Country._array.length;
}
Country.array = function() {
    return Country._array;
}


Country.prototype.MAX_HEXES = 100;
Country.prototype.MIN_HEXES = 30;

Country.prototype.LAKE_COLOR = "white";

Country.prototype.color = function() { return this._color; };


Country.prototype.getHexes = function() {
    return this._hexes;
}

Country.prototype.isLake = function() {
    return this._isLake;
}

// Find a hex that is adjacent to this country but is not occupied by this country.
// This can be used to grow this country, to find a new place to start a country,
// or to figure out whom to attack.
Country.prototype.findAdjacentHex = function(mustBeEmpty) {
    var self = this;

    // Pick a starting hex randomly. Then iterate through until one is hopefully found.
    // var startingHexPos = Math.floor(Math.random() * this._hexes.length);
    for (var i = 0; i < this._hexes.length; i++) {
        // Try to find a neighboring spot that works.
        var hex = Math.floor(Math.random() * this._hexes.length);

        //Iterate over directions from the hex again randomly to see if one works.
        for ( var j = 0; j < Dir.array.length; j++) {
            var dir = Dir.array[Math.floor(Math.random() * Dir.array.length)];
            var newHex = Dir.nextHex(this._hexes[hex], dir);
            if (newHex && (mustBeEmpty ? newHex.country() == null : newHex.country() != self)) {
                return newHex;
            }

        }
    }

    return null;

}

Country.prototype.growCountry = function() {
    if (this._hexes.length >= this._numHexes) {
        return;
    }

    var hex = this.findAdjacentHex(true);

    if (!hex) {
        Globals.debug("Couldn't find a new spot for a hex!");        
        return;
    }

    hex.setCountry(this);
    this._hexes.push(hex);

    // Tail recursion to get the right number.
    this.growCountry();

};



// Absorbs a lake into an adjacent country.
Country.prototype.absorbLake = function() {
    var newCountry = null;
    for (var i = 0; i < this._hexes.length; i++) {
        for (var j = 0; j < Dir.array.length; j++) {
            var newHex = Dir.nextHex(this._hexes[i], j);
            if (newHex && newHex.country() && !newHex.country().isLake()) {
                newCountry = newHex.country();
                break;
            }
        }
        if (newCountry) {
            break;
        }
    }

    if (newCountry) {
        this._hexes.forEach(function(hex) {
            hex.setCountry(newCountry);
            newCountry._hexes.push(hex);
        });
        this._hexes = [];
    }

}

// Marks hexes as internal or external. Also identifies which edges need border stroking for the hex.
Country.prototype.markHexes = function() {
    var self = this;
    this._hexes.forEach(function(hex) {
        var countryEdges = [];
        for (var i = 0; i < Dir.array.length; i++) {
            var newHex = Dir.nextHex(hex, i);
            // Lakes have somewhat different rules.
            if (self.isLake()) {
                if (newHex && newHex.country() && !newHex.country().isLake()) {
                    countryEdges.push(i);
                }
            } else if (!newHex || newHex.country() != self) {
                countryEdges.push(i);                
            }
        }
        hex.setCountryEdgeDirections(countryEdges);
    });
}

Country.prototype.paint = function() {
    this._hexes.forEach(function(elem) {
        elem.paint();
    });
}



function go() {

    Globals.context.clearRect(0,0,2000,2000);
    Globals.context.lineJoin = "straight";
    
    var colorsel = ["red", "blue", "lightgreen", "forestgreen", "purple", "pink", "orange", "yellow"];

    // Clear the Hex and Country statics.
    Hex.init(); 
    Country.init();
    var country = new Country(Hex.get(Math.floor(Math.random() * Hex.prototype.TOTAL_HEXES)), "black");

    for (var i = 0; i < 29; i++) {
        var countryStart = Math.floor(Math.random() * Country.count());
        var adjacentHex;
        console.log(Country.count());
        for (var j = 0; j < Country.count(); j++) {
            adjacentHex = Country.get((j + countryStart) % Country.count()).findAdjacentHex(true);
            if (adjacentHex) {
                break;
            }
        }
        if (!adjacentHex) {
            Globals.debug("RAN OUT OF SPACE!", i);
            break;
        }
        var newCountry = new Country(adjacentHex, colorsel[i % 8]);
        if (newCountry.isLake()) {
            i--;
        }
    }

    Country.array().forEach(function(country) {
        country.markHexes();
        country.paint();
    });

}

function mouseMove(event) {
/*
    var path = new Path2D();
    path.moveTo(0,0);
    path.lineTo(event.offsetX, event.offsetY);   
    path.closePath();
    Globals.context.stroke(path);
    */

//      console.log(event);
//    document.getElementById("info").textContent += "hello";
    var hex = Hex.fromMousePos(event.offsetX, event.offsetY);
//    hex._color = "red";
//    hex.paint();
//    document.getElementById("info").textContent = hex.num();
    document.getElementById("info").textContent = hex;
}


//Country.prototype.


</script>


